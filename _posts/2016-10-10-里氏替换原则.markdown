---
layout: post
title: 里氏替换原则
date: 2016-10-10 19:56:00
categories: 设计模式
tags: 设计模式
---




#第2章　里氏替换原则（Liskov Substitution Principle，LSP）

##在面向对象的语言中
### 继承它有如下优点：
```java
- 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；
- 提高代码的重用性；
- 子类可以形似父类，但又异于父类，“龙生龙，凤生凤，老鼠生来会打洞”是说子拥有父的“种”，“世界上没有两片完全相同的叶子”是指明子与父的不同；
- 提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，君不见很多开源框架的扩展接口都是通过继承父类来完成的；
- 提高产品或项目的开放性。
```

### 继承的缺点如下：

```java
- 1.继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；
- 2.降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；
- 3.增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构。
```
--------
--------
--------

# 什么是里氏替换原则呢？
## 它有两种定义：
### 第一种定义，也是最正宗的定义：
```java
If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。）
```
### 第二种定义：
```java
 Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）
```
        
        第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。

--------
--------
--------
# 里氏替换原则:

## 1.子类必须完全实现父类的方法
【注意】在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。

在Java的基础知识中都会讲到继承，Java的三大特征嘛，封装、继承、多态。继承就是告诉你拥有父类的方法和属性，然后你就可以重写父类的方法。
按照继承原则，我们上面的玩具枪继承AbstractGun是绝对没有问题的，玩具枪也是枪嘛。
但是在具体应用场景中就要考虑下面这个问题了：子类是否能够完整地实现父类的业务，否则就会出现像上面的拿枪杀敌人时却发现是把玩具枪的笑话。
【注意】　如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合（紧密的聚集关系）等关系代替继承。

## 2.子类可以有自己的个性
就是说，人是人，学生也是人，任何一个学生都是人（向上转型），但不是任何人都是学生，只有（本质上）是学生的人，才是学生（向下转型是有条件的）
```java
Person p=new Student（）；//向上转型，无条件，任何学生都是人
Student s=（Student）p；//向下是有条件的，只有（本质上）是学生的人，才是学生
```
父类出现的地方，子类都可以出现以替换，但是子类出现的地方，父类不一定能够替换

## 3.覆盖或实现父类的方法时输入参数可以被放大
子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松。
①如果是相同的话，那么是对父类中同名方法的重写，此时，并没有改变父类“定义的规则”。
父类调用方法的的地方，子类也能调用，并满足场景的要求，满足里氏替换原则，
②如果是参数类型被放大（向上抽象）这个时候，相当于是复写了父类的同名方法，因为继承的同时，子类中就已经有了父类的方法，再此重写时，虽然方法名和返回值类型均相同，但是参数列表不同了，因此，是对父类的同名方法的复写
父类调用方法的地方，子类同样能调用参数形式一样的父类中的方法，如果没有特意放大参数，那么子类中定义的这个方法将不会被调用（特殊需求时，可做他用），但是，此时符合里氏替换原则
③如果在实现的时候，对父类的参数进行缩小
父类调用方法的地方，子类调用时就会选择子类中参数缩小的方法，出现与实际需求不符合的情况。不符合里氏替换原则

## 4. 覆写或实现父类的方法时输出结果可以被缩小
这是什么意思呢，父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类，为什么呢？分两种情况，如果是覆写，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。如果是重载，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的，参考上面讲的前置条件。

--------
采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常完美！

在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，把子类当做父类使用，子类的“个性”被抹杀——委屈了点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。
